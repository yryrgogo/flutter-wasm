use serde::{Deserialize, Serialize};
use sqlx::{postgres::PgQueryResult, FromRow, PgPool};

#[derive(Debug, FromRow, Deserialize, Serialize)]
pub struct QuestRequirements {
    quest_id: i32,
    required_quest_id: Option<i32>,
    required_mission_id: Option<i32>,
}

impl QuestRequirements {
    pub async fn insert(&self, pool: &PgPool) -> Result<PgQueryResult, sqlx::Error> {
        let query = r#"
            INSERT INTO quest_requirements (quest_id, required_quest_id, required_mission_id)
            VALUES ($1, $2, $3);
        "#;
        let result = sqlx::query(query)
            .bind(self.quest_id)
            .bind(self.required_quest_id)
            .bind(self.required_mission_id)
            .execute(pool)
            .await
            .expect("Failed to insert quest requirements.");

        Ok(result)
    }

    pub async fn find_all_by_quest(pool: &PgPool, quest_id: i32) -> Result<Vec<Self>, sqlx::Error> {
        let query = "SELECT quest_id, required_quest_id, required_mission_id FROM quest_requirements WHERE quest_id = $1 ORDER BY quest_id, required_quest_id, required_mission_id ASC";
        let rows = sqlx::query_as::<_, Self>(query)
            .bind(quest_id)
            .fetch_all(pool)
            .await?;

        Ok(rows)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        db::client::connect,
        models::{item::Item, mission::Mission, quest::Quest, reward::Reward},
    };

    #[tokio::test]
    async fn test_insert_find() {
        let pool = connect().await.expect("Failed to connect to Postgres.");

        let item = Item {
            id: 1,
            name: "item1".to_string(),
            description: "item1 description".to_string(),
            item_type: "type1".to_string(),
        };
        item.insert(&pool).await.expect("Failed to insert item.");

        let reward = Reward {
            id: 1,
            item_id: 1,
            quantity: 10,
        };
        reward
            .insert(&pool)
            .await
            .expect("Failed to insert reward.");

        let quest = Quest {
            id: 1,
            name: "Test Quest".to_string(),
            quest_type: "Test".to_string(),
            description: "This is a test quest.".to_string(),
            objective: "Complete the test.".to_string(),
            reward_id: 1,
        };
        quest.insert(&pool).await.expect("Failed to insert quest.");

        let quest2 = Quest {
            id: 2,
            name: "Test Quest".to_string(),
            quest_type: "Test".to_string(),
            description: "This is a test quest.".to_string(),
            objective: "Complete the test.".to_string(),
            reward_id: 1,
        };
        quest2.insert(&pool).await.expect("Failed to insert quest.");

        let quest_requirements = QuestRequirements {
            quest_id: 1,
            required_quest_id: Some(2),
            required_mission_id: None,
        };

        let insert_result = quest_requirements.insert(&pool).await.unwrap();
        assert_eq!(insert_result.rows_affected(), 1);

        let mission = Mission {
            id: 1, // it will be autogenerated by the SERIAL PRIMARY KEY
            name: String::from("Mission Test"),
            description: String::from("Test the mission struct"),
            objective: String::from("Check if the mission can be stored and retrieved"),
            mission_type: String::from("test"),
            requirements: serde_json::json!({"test": "test"}),
        };

        mission
            .insert(&pool)
            .await
            .expect("Failed to insert mission.");

        let quest_requirements2 = QuestRequirements {
            quest_id: 1,
            required_quest_id: None,
            required_mission_id: Some(1),
        };

        let insert_result2 = quest_requirements2.insert(&pool).await.unwrap();
        assert_eq!(insert_result2.rows_affected(), 1);

        let retrieved_requirements =
            QuestRequirements::find_all_by_quest(&pool, quest_requirements.quest_id)
                .await
                .expect("Failed to find quest requirements.");

        assert_eq!(retrieved_requirements.len(), 2);
        assert_eq!(
            retrieved_requirements[0].quest_id,
            quest_requirements.quest_id
        );
        assert_eq!(
            retrieved_requirements[0].required_quest_id,
            quest_requirements.required_quest_id
        );
        assert_eq!(
            retrieved_requirements[0].required_mission_id,
            quest_requirements.required_mission_id
        );
        assert_eq!(
            retrieved_requirements[1].quest_id,
            quest_requirements2.quest_id
        );
        assert_eq!(
            retrieved_requirements[1].required_quest_id,
            quest_requirements2.required_quest_id
        );
        assert_eq!(
            retrieved_requirements[1].required_mission_id,
            quest_requirements2.required_mission_id
        );
    }
}
