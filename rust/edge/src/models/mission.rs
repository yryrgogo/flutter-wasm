use serde::Serialize;
use sqlx::{
    postgres::{PgQueryResult, PgRow},
    FromRow, PgPool,
};

#[derive(Debug, FromRow, Serialize)]
pub struct Mission {
    pub id: i32,
    pub name: String,
    pub description: String,
    pub objective: String,
    pub mission_type: String,
    pub requirements: serde_json::Value,
}

impl Mission {
    pub async fn insert(&self, pool: &PgPool) -> sqlx::Result<PgQueryResult> {
        let result = sqlx::query(
            r#"
            INSERT INTO missions (name, description, objective, mission_type, requirements)
            VALUES ($1, $2, $3, $4, $5)
        "#,
        )
        .bind(&self.name)
        .bind(&self.description)
        .bind(&self.objective)
        .bind(&self.mission_type)
        .bind(&self.requirements)
        .execute(pool)
        .await
        .expect("Failed to insert mission.");

        Ok(result)
    }

    pub async fn find(pool: &PgPool, mission_id: i32) -> Result<Option<Self>, sqlx::Error> {
        let query = "SELECT id, name, description, objective, mission_type, requirements FROM missions WHERE id = $1";
        let row: Option<PgRow> = sqlx::query(query)
            .bind(mission_id)
            .fetch_optional(pool)
            .await
            .expect("Failed to execute query.");

        if let Some(row) = row {
            Ok(Some(Mission::from_row(&row).unwrap()))
        } else {
            Ok(None)
        }
    }

    pub async fn find_all(pool: &PgPool) -> sqlx::Result<Vec<Mission>> {
        let missions = sqlx::query_as::<_, Mission>(
            r#"
            SELECT * FROM missions
        "#,
        )
        .fetch_all(pool)
        .await?;

        Ok(missions)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::db::client::connect;

    #[tokio::test]
    async fn test_insert_find() {
        let pool = connect().await.expect("Failed to connect to Postgres.");

        let mission = Mission {
            id: 1, // it will be autogenerated by the SERIAL PRIMARY KEY
            name: String::from("Mission Test"),
            description: String::from("Test the mission struct"),
            objective: String::from("Check if the mission can be stored and retrieved"),
            mission_type: String::from("test"),
            requirements: serde_json::json!({"test": "test"}),
        };

        let insert_result = mission
            .insert(&pool)
            .await
            .expect("Failed to insert mission.");
        assert_eq!(insert_result.rows_affected(), 1);

        let missions = Mission::find_all(&pool)
            .await
            .expect("Failed to find missions.");
        assert_ne!(missions.len(), 0);

        let retrieved_mission = Mission::find(&pool, mission.id)
            .await
            .expect("Failed to find mission.")
            .unwrap_or_else(|| panic!("Failed to find mission with id {}.", mission.id));

        assert_eq!(retrieved_mission.id, mission.id);
        assert_eq!(retrieved_mission.name, mission.name);
        assert_eq!(retrieved_mission.description, mission.description);
        assert_eq!(retrieved_mission.objective, mission.objective);
        assert_eq!(retrieved_mission.mission_type, mission.mission_type);
        assert_eq!(retrieved_mission.requirements, mission.requirements);
    }
}
