use serde::Serialize;
use sqlx::{
    postgres::{PgQueryResult, PgRow},
    FromRow, PgPool,
};

#[derive(Debug, FromRow, Serialize)]
pub struct MissionSteps {
    pub id: i32,
    pub step_order: i32,
    pub mission_id: i32,
    pub status: String,
    pub description: String,
    pub step_image_url: Option<String>,
}

impl MissionSteps {
    pub async fn insert(&self, pool: &PgPool) -> Result<PgQueryResult, sqlx::Error> {
        let query = r#"
            INSERT INTO mission_steps (step_order, mission_id, status, description, step_image_url)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT (id) DO NOTHING;
        "#;
        let result = sqlx::query(query)
            .bind(self.step_order)
            .bind(self.mission_id)
            .bind(&self.status)
            .bind(&self.description)
            .bind(&self.step_image_url)
            .execute(pool)
            .await
            .expect("Failed to insert mission step.");

        Ok(result)
    }

    pub async fn find(pool: &PgPool, step_id: i32) -> Result<Option<Self>, sqlx::Error> {
        let query = "SELECT id, step_order, mission_id, status, description, step_image_url FROM mission_steps WHERE id = $1";
        let row: Option<PgRow> = sqlx::query(query)
            .bind(step_id)
            .fetch_optional(pool)
            .await
            .expect("Failed to execute query.");

        if let Some(row) = row {
            Ok(Some(MissionSteps::from_row(&row).unwrap()))
        } else {
            Ok(None)
        }
    }

    pub async fn find_by_mission_id(
        pool: &PgPool,
        mission_id: i32,
    ) -> Result<Option<Self>, sqlx::Error> {
        let query = "SELECT id, step_order, mission_id, status, description, step_image_url FROM mission_steps WHERE mission_id = $1 ORDER BY step_order ASC";
        let row: Option<PgRow> = sqlx::query(query)
            .bind(mission_id)
            .fetch_optional(pool)
            .await
            .expect("Failed to execute query.");

        if let Some(row) = row {
            Ok(Some(MissionSteps::from_row(&row).unwrap()))
        } else {
            Ok(None)
        }
    }

    pub async fn find_all(pool: &PgPool) -> Result<Vec<Self>, sqlx::Error> {
        let query = "SELECT id, step_order, mission_id, status, description, step_image_url FROM mission_steps";
        let rows = sqlx::query_as::<_, Self>(query).fetch_all(pool).await?;
        Ok(rows)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{db::client::connect, models::mission::Mission};

    #[tokio::test]
    async fn test_insert_find() {
        let pool = connect().await.expect("Failed to connect to Postgres.");

        let mission = Mission {
            id: 1, // it will be autogenerated by the SERIAL PRIMARY KEY
            name: String::from("Mission Test"),
            description: String::from("Test the mission struct"),
            objective: String::from("Check if the mission can be stored and retrieved"),
            mission_type: String::from("test"),
            requirements: serde_json::json!({"test": "test"}),
        };

        mission
            .insert(&pool)
            .await
            .expect("Failed to insert mission.");

        let mission_step = MissionSteps {
            id: 1,
            step_order: 1,
            mission_id: 1,
            status: "Pending".to_string(),
            description: "Step 1 description".to_string(),
            step_image_url: Some("https://example.com/step1.png".to_string()),
        };
        let insert_result = mission_step.insert(&pool).await.unwrap();
        assert_eq!(insert_result.rows_affected(), 1);

        let steps = MissionSteps::find_all(&pool)
            .await
            .expect("Failed to find mission steps.");
        assert_ne!(steps.len(), 0);

        let retrieved_step = MissionSteps::find(&pool, mission_step.id)
            .await
            .expect("Failed to find mission step.")
            .unwrap_or_else(|| panic!("Failed to find mission step with id {}.", mission_step.id));
        assert_eq!(retrieved_step.id, mission_step.id);
        assert_eq!(retrieved_step.step_order, mission_step.step_order);
        assert_eq!(retrieved_step.mission_id, mission_step.mission_id);
        assert_eq!(retrieved_step.status, mission_step.status);
        assert_eq!(retrieved_step.description, mission_step.description);
        assert_eq!(retrieved_step.step_image_url, mission_step.step_image_url);
    }
}
